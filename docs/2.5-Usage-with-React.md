# Usage with React
From the very beginning, we need to stress that Redux has no relation to React. You can write Redux apps with React, Angular, Ember, jQuery, or vanilla JavaScript.

å…ˆå¼ºè°ƒä¸€ä¸‹ï¼ŒReduxè·ŸReactæ²¡æœ‰åŠæ¯›é’±å…³ç³»ã€‚ä½ å¯ä»¥ç”¨Reduxä¼´éšReact, Angular, Ember, jQueryç”šè‡³æ™®é€šJavaScriptä»»æ„ä¹‹ä¸€æœç”¨ã€‚

That said, Redux works especially well with frameworks like React and Deku because they let you describe UI as a function of state, and Redux emits state updates in response to actions.

ä¸è¿‡è¯è¯´å›æ¥ï¼ŒReduxè·ŸReactå’ŒDekuè¿™ç§æ¡†æ¶æœ€åˆå¾—æ¥ï¼Œæ¯•ç«Ÿè¿™äº›æ¡†æ¶ç”¨stateæ¥æè¿°ç•Œé¢ï¼Œè€ŒReduxä¼šéšç€actionsè§¦å‘stateçš„æ›´æ–°ã€‚ï¼ˆå¤©é€ åœ°è®¾ï¼‰

We will use React to build our simple todo app.

## Installing React Redux

React bindings are not included in Redux by default. You need to install them explicitly:

Reactå¹¶ä¸è‡ªå¸¦Reduxã€‚æ‰€ä»¥è¦å®‰è£…ä¸€ä¸‹ï¼š

```Shell
npm install --save react-redux
```

If you donâ€™t use npm, you may grab the latest UMD build from unpkg (either a development or a production build). The UMD build exports a global called window.ReactRedux if you add it to your page via a &lt;script&gt; tag.

å¦‚æœä½ ä¸ç”¨npmï¼Œä½ å¯ä»¥ä¸‹è½½ä¸‹æ¥ï¼Œç”¨&lt;script&gt;æ ‡ç­¾å¼•å…¥ï¼Œè¿™æ ·window.ReactReduxè¿™æ ·çš„å…¨å±€å˜é‡å°±å¯ä»¥ç”¨äº†ã€‚

## Presentational and Container Components

React bindings for Redux embrace the idea of separating presentational and container components. If youâ€™re not familiar with these terms, read about them first, and then come back. They are important, so weâ€™ll wait!

Reactçš„Reduxæå€¡å±•ç¤ºç±»componentå’Œå®¹å™¨ç±»componentåŒºåˆ†å¼€æ¥çš„æƒ³æ³•ã€‚ä½ è¦æ˜¯ä¸æ‡‚ï¼Œæ»šå»è¯»ğŸ˜‚ã€‚è¯»ä¸æ‡‚å°±ä¸è¦å›æ¥ã€‚

Finished reading the article? Letâ€™s recount their differences:

è¯»å®Œäº†å§ï¼Ÿæˆ‘ä»¬å†åˆ—ä¸¾ä¸€ä¸‹ä»–ä»¬çš„åŒºåˆ«ï¼š

head | Presentational Components | Container Components
--- | --- | ---
Purpose |	How things look (markup, styles) | How things work (data fetching, state updates)
Aware of Redux |	No |	Yes
To read data | Read data from props	| Subscribe to Redux state
To change data | Invoke callbacks from props | Dispatch Redux actions
Are written	By hand | Usually generated | by React Redux



Most of the components weâ€™ll write will be presentational, but weâ€™ll need to generate a few container components to connect them to the Redux store.

æˆ‘ä»¬è¦å†™çš„componentå¤§éƒ¨åˆ†æ˜¯å±•ç¤ºç±»çš„ï¼Œä¸è¿‡ä¹Ÿéœ€è¦å†™ä¸€äº›å®¹å™¨ç±»componentæ¥è¿æ¥åˆ°Redux store.

Technically you could write the container components by hand using store.subscribe(). We donâ€™t advise you to do this because React Redux makes many performance optimizations that are hard to do by hand. For this reason, rather than write container components, we will generate them using the connect() function provided by React Redux, as you will see below.

ç†è®ºä¸Šä½ å¯ä»¥ç”¨store.subscribe()è‡ªå·±æ‰‹å†™å®¹å™¨ç±»componentã€‚ä¸è¿‡ä¸å»ºè®®è¿™æ ·åšï¼Œå› ä¸ºReact Reduxåšäº†å¾ˆå¤šä¼˜åŒ–ã€‚é‰´äºè¿™ä¸ªåŸå› ï¼Œæˆ‘ä»¬å°±ä¸æ‰‹å†™äº†ï¼Œè€Œæ˜¯ä½¿ç”¨React Reduxæä¾›çš„connect()æ–¹æ³•ç”Ÿæˆã€‚

## Designing Component Hierarchy

## è®¾è®¡Componentå±‚æ¬¡ä½“ç³»

Remember how we designed the shape of the root state object? Itâ€™s time we design the UI hierarchy to match it. This is not a Redux-specific task. Thinking in React is a great tutorial that explains the process.

è¿˜è®°å¾—æˆ‘ä»¬æ€ä¹ˆè®¾è®¡root stateçš„å—ï¼Ÿç°åœ¨æˆ‘ä»¬è¦è®¾è®¡ä¸€å¥—ç•Œé¢çš„å±‚æ¬¡ç»“æ„æ¥å¯¹æ¥å®ƒäº†ã€‚è¿™ä¸ªæµç¨‹å¹¶ä¸ä¸“å±äºReduxã€‚Thinking in Reactå¯¹è¿™ä¸ªæµç¨‹è§£é‡Šå¾—å¾ˆå¥½ã€‚

Our design brief is simple. We want to show a list of todo items. On click, a todo item is crossed out as completed. We want to show a field where the user may add a new todo. In the footer, we want to show a toggle to show all, only completed, or only active todos.

æˆ‘ä»¬çš„è®¾è®¡ä¹Ÿå¾ˆç®€å•ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªtodoçš„åˆ—è¡¨ã€‚ç‚¹ä¸€ä¸‹ä¸€ä¸ªtodoï¼Œå®ƒå°±è¢«æ ‡è®°ä¸ºå·²å®Œæˆã€‚å¦å¤–ï¼Œè¦æä¾›ä¸€ä¸ªæ·»åŠ æ–°todoçš„åŒºåŸŸã€‚åœ¨åº•éƒ¨ï¼Œæˆ‘ä»¬æƒ³æä¾›ä¸€äº›è¿‡æ»¤æ¡ä»¶æ¥å±•ç¤ºå…¨éƒ¨ï¼Œå·²å®Œæˆå’Œæ¿€æ´»çš„todosã€‚

### Presentational Components

I see the following presentational components and their props emerge from this brief:

ä»ä¸Šé¢çš„è®¾è®¡ç®€æŠ¥ï¼Œå¯ä»¥å¾—åˆ°ä»¥ä¸‹å±•ç¤ºç±»componentsï¼š

* TodoList is a list showing visible todos.
  * todos: Array is an array of todo items with { id, text, completed } shape.
  * onTodoClick(id: number) is a callback to invoke when a todo is clicked.
* Todo is a single todo item.
  * text: string is the text to show.
  * completed: boolean is whether todo should appear crossed out.
  * onClick() is a callback to invoke when a todo is clicked.
* Link is a link with a callback.
  * onClick() is a callback to invoke when link is clicked.
* Footer is where we let the user change currently visible todos.
* App is the root component that renders everything else.

* TodoListï¼šæ˜¯ä¸€ä¸ªå±•ç¤ºå¯è§todosçš„åˆ—è¡¨ã€‚ï¼ˆå¯è§ä¸å¯è§å…¨çœ‹filterï¼‰
  * todosï¼šä¸€ä¸ªArrayï¼ŒåŒ…å«å…¨éƒ¨todoï¼Œ{id, text, completed}çš„æ ·å­ã€‚
  * onTodoClick(id: number) ç‚¹å‡»todoä¹‹åçš„å›è°ƒå‡½æ•°ã€‚
* Todoï¼šå•ç‹¬çš„todoé¡¹ã€‚
* Linkï¼šä¸€ä¸ªå¸¦å›è°ƒçš„é“¾æ¥ã€‚
* Footerï¼šè®©ç”¨æˆ·æ›´æ”¹å½“å‰å¯è§todosçš„åœ°æ–¹ã€‚
* Appï¼šæ ¹componentã€‚

They describe the look but donâ€™t know where the data comes from, or how to change it. They only render whatâ€™s given to them. If you migrate from Redux to something else, youâ€™ll be able to keep all these components exactly the same. They have no dependency on Redux.

ä»–ä»¬åªæè¿°ç•Œé¢ï¼Œä¸ç®¡æ•°æ®ä»å“ªæ¥ï¼Œå¦‚ä½•æ”¹å˜ã€‚ç»™å®ƒä»¬å•¥ï¼Œå®ƒä»¬å°±renderå•¥ã€‚å¦‚æœå“ªå¤©ä½ æŠ›å¼ƒRedux(QAQ)é€‰ç”¨å…¶ä»–çš„ï¼Œè¿™äº›éƒ½ä¸éœ€è¦æ”¹å˜ã€‚å®ƒä»¬æ ¹æœ¬ä¸ä¾èµ–Reduxã€‚

### Container Components

We will also need some container components to connect the presentational components to Redux. For example, the presentational TodoList component needs a container like VisibleTodoList that subscribes to the Redux store and knows how to apply the current visibility filter. To change the visibility filter, we will provide a FilterLink container component that renders a Link that dispatches an appropriate action on click:

æˆ‘ä»¬ä¹Ÿéœ€è¦å®¹å™¨componentæ¥è¿æ¥å±•ç¤ºç±»componentåˆ°Reduxã€‚æ¯”å¦‚ï¼Œå±•ç¤ºç±»TodoListéœ€è¦ä¸€ä¸ªVisibleTodoListè¿™æ ·çš„å®¹å™¨componentæ¥æ³¨å†Œç›‘å¬Redux storeå’Œä½¿ç”¨filterã€‚è¦ä¿®æ”¹visibility filterï¼Œæˆ‘ä»¬æä¾›ä¸€ä¸ªFilterLinkå®¹å™¨componentæ¥renderä¸€ä¸ªLinkï¼Œè¿™ä¸ªLinkä¼šåœ¨ç‚¹å‡»æ—¶å‘èµ·actionï¼š

* VisibleTodoList filters the todos according to the current visibility filter and renders a TodoList.
* FilterLink gets the current visibility filter and renders a Link.
  * filter: string is the visibility filter it represents.

* VisibleTodoListï¼šæ ¹æ®å½“å‰çš„å¯è§æ€§æ¥è¿‡æ»¤todosï¼Œå¹¶renderä¸€ä¸ªTodoListã€‚
* FilterLinkï¼šè·å–å½“å‰visibility filterå¹¶renderä¸€ä¸ªLink.
  * filter: ä»£è¡¨visibilityçš„å­—ç¬¦ä¸²ã€‚

### Other Components

Sometimes itâ€™s hard to tell if some component should be a presentational component or a container. For example, sometimes form and function are really coupled together, such as in case of this tiny component:

æœ‰æ—¶å€™å¾ˆéš¾æŠŠä¸€äº›componentä¸¥æ ¼å½’ç±»ä¸ºå±•ç¤ºç±»æˆ–æ˜¯å®¹å™¨ç±»ã€‚æ¯”å¦‚ï¼Œä¸€äº›formè¡¨å•å’Œæ–¹æ³•æ˜¯é…å¥—çš„ï¼Œæ¯”å¦‚æˆ‘ä»¬ä¾‹å­é‡Œçš„è¿™ä¸ªå°componentï¼š

* AddTodo is an input field with an â€œAddâ€ button

* AddTodoï¼šä¸€ä¸ªinputå¤–åŠ ä¸€ä¸ªâ€œæ·»åŠ â€æŒ‰é’®

Technically we could split it into two components but it might be too early at this stage. Itâ€™s fine to mix presentation and logic in a component that is very small. As it grows, it will be more obvious how to split it, so weâ€™ll leave it mixed.

ç†è®ºä¸Šæˆ‘ä»¬åº”è¯¥æŠŠå®ƒåˆ†å‰²æˆ2ä¸ªcomponentsï¼Œä¸è¿‡ä¸ºæ—¶å¤ªæ—©ã€‚å¦‚æœcomponentå¾ˆå°çš„è¯ï¼ŒæŠŠå±•ç¤ºå’Œé€»è¾‘æ”¾åœ¨ä¸€èµ·ä¹Ÿæœªå°ä¸å¯ã€‚ç­‰å®ƒè¶Šæ¥è¶Šå¤æ‚ï¼Œå†è€ƒè™‘åˆ†å¼€å†™ã€‚

## Implementing Components

Letâ€™s write the components! We begin with the presentational components so we donâ€™t need to think about binding to Redux yet.

å…ˆæ— è§†Reduxå†™å±•ç¤ºç±»componentsã€‚

### Presentational Components

These are all normal React components, so we wonâ€™t examine them in detail. We write functional stateless components unless we need to use local state or the lifecycle methods. This doesnâ€™t mean that presentational components have to be functionsâ€”itâ€™s just easier to define them this way. If and when you need to add local state, lifecycle methods, or performance optimizations, you can convert them to classes.

components/Todo.js

```JavaScript
import React, { PropTypes } from 'react'

const Todo = ({ onClick, completed, text }) => (
  <li
    onClick={onClick}
    style={{
      textDecoration: completed ? 'line-through' : 'none'
    }}
  >
    {text}
  </li>
)

Todo.propTypes = {
  onClick: PropTypes.func.isRequired,
  completed: PropTypes.bool.isRequired,
  text: PropTypes.string.isRequired
}

export default Todo
```

components/TodoList.js

```JavaScript
import React, { PropTypes } from 'react'
import Todo from './Todo'

const TodoList = ({ todos, onTodoClick }) => (
  <ul>
    {todos.map(todo =>
      <Todo
        key={todo.id}
        {...todo}
        onClick={() => onTodoClick(todo.id)}
      />
    )}
  </ul>
)

TodoList.propTypes = {
  todos: PropTypes.arrayOf(PropTypes.shape({
    id: PropTypes.number.isRequired,
    completed: PropTypes.bool.isRequired,
    text: PropTypes.string.isRequired
  }).isRequired).isRequired,
  onTodoClick: PropTypes.func.isRequired
}

export default TodoList
```

components/Link.js

```JavaScript
import React, { PropTypes } from 'react'

const Link = ({ active, children, onClick }) => {
  if (active) {
    return <span>{children}</span>
  }

  return (
    <a href="#"
       onClick={e => {
         e.preventDefault()
         onClick()
       }}
    >
      {children}
    </a>
  )
}

Link.propTypes = {
  active: PropTypes.bool.isRequired,
  children: PropTypes.node.isRequired,
  onClick: PropTypes.func.isRequired
}

export default Link
```

components/Footer.js

```JavaScript
import React from 'react'
import FilterLink from '../containers/FilterLink'

const Footer = () => (
  <p>
    Show:
    {" "}
    <FilterLink filter="SHOW_ALL">
      All
    </FilterLink>
    {", "}
    <FilterLink filter="SHOW_ACTIVE">
      Active
    </FilterLink>
    {", "}
    <FilterLink filter="SHOW_COMPLETED">
      Completed
    </FilterLink>
  </p>
)

export default Footer
```

components/App.js

```JavaScript
import React from 'react'
import Footer from './Footer'
import AddTodo from '../containers/AddTodo'
import VisibleTodoList from '../containers/VisibleTodoList'

const App = () => (
  <div>
    <AddTodo />
    <VisibleTodoList />
    <Footer />
  </div>
)

export default App
```

### Container Components

Now itâ€™s time to hook up those presentational components to Redux by creating some containers. Technically, a container component is just a React component that uses store.subscribe() to read a part of the Redux state tree and supply props to a presentational component it renders. You could write a container component by hand but React Redux includes many useful optimizations so we suggest to generate container components with connect() function from the React Redux library.

ç°åœ¨è¯¥åˆ›å»ºä¸€äº›å®¹å™¨æ¥æŠŠå±•ç¤ºç±»componentsè¿æ¥èµ·æ¥äº†ã€‚ç†è®ºä¸Šï¼Œä¸€ä¸ªå®¹å™¨componentæ˜¯ä¸€ä¸ªReactçš„componentï¼Œå®ƒé€šè¿‡store.subscribe()æ¥è¯»å–éƒ¨åˆ†Reduxçš„stateæ ‘ï¼Œå¹¶é€šè¿‡propsæŠŠæ•°æ®ä¼ ç»™å±•ç¤ºç±»componentæ¥renderã€‚ä½ å½“ç„¶å¯ä»¥è‡ªå·±å†™ä¸€ä¸ªå®¹æ˜“componentäº†ï¼Œä½†æ˜¯React ReduxåŒ…å«é‚£ä¹ˆå¤šä¼˜åŒ–ï¼Œæ‰€ä»¥å»ºè®®ä½¿ç”¨React Reduxåº“é‡Œçš„connect()æ–¹æ³•æ¥ç”Ÿæˆå®¹å™¨componentã€‚

To use connect(), you need to define a special function called mapStateToProps that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, VisibleTodoList needs to calculate todos to pass to the TodoList, so we define a function that filters the state.todos according to the state.visibilityFilter, and use it in its mapStateToProps:

è¦ä½¿ç”¨connect()ï¼Œä½ è¦å†™ä¸€ä¸ªå«åšmapStateToPropsçš„æ–¹æ³•æ¥å®šä¹‰ä»å½“å‰å­˜åœ¨Reduxçš„storeä¸­çš„stateåˆ°å±•ç¤ºç±»componentçš„propsçš„è½¬æ¢ã€‚æ¯”å¦‚ï¼ŒVisibleTodoListéœ€è¦å¤„ç†ä¼ ç»™TodoListçš„todosï¼Œæ‰€ä»¥æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–¹æ³•æ ¹æ®state.visibilityFilterè¿‡æ»¤state.todosï¼Œå¹¶åœ¨mapStateToPropsä¸­ä½¿ç”¨ï¼š

```JavaScript
const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case 'SHOW_ALL':
      return todos
    case 'SHOW_COMPLETED':
      return todos.filter(t => t.completed)
    case 'SHOW_ACTIVE':
      return todos.filter(t => !t.completed)
  }
}

const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}
```

In addition to reading the state, container components can dispatch actions. In a similar fashion, you can define a function called mapDispatchToProps() that receives the dispatch() method and returns callback props that you want to inject into the presentational component. For example, we want the VisibleTodoList to inject a prop called onTodoClick into the TodoList component, and we want onTodoClick to dispatch a TOGGLE_TODO action:

é™¤äº†è¯»å–stateï¼Œå®¹å™¨ç±»componentè¿˜å¯ä»¥é…å‘actionsã€‚ç±»ä¼¼çš„ï¼Œä½ å¯ä»¥å®šä¹‰ä¸€ä¸ªå«åšmapDispatchToProps()æ–¹æ³•æ¥æ¥å—dispatch()æ–¹æ³•å¹¶è¿”å›å›è°ƒï¼ˆTODO: è¿™ç‰¹ä¹ˆçš„åˆ°åº•åœ¨è¯´å•¥ï¼ï¼‰ä¾‹å¦‚ï¼š

```JavaScript
const mapDispatchToProps = (dispatch) => {
  return {
    onTodoClick: (id) => {
      dispatch(toggleTodo(id))
    }
  }
}
```

Finally, we create the VisibleTodoList by calling connect() and passing these two functions:

æœ€ç»ˆï¼Œæˆ‘ä»¬ä½¿ç”¨connectæŠŠè¿™ä¿©æ–¹æ³•è¿æ¥ç»™VisibleTodoListï¼š

```JavaScript
import { connect } from 'react-redux'

const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList)

export default VisibleTodoList
```

These are the basics of the React Redux API, but there are a few shortcuts and power options so we encourage you to check out its documentation in detail. In case you are worried about mapStateToProps creating new objects too often, you might want to learn about computing derived data with reselect.

Find the rest of the container components defined below:

containers/FilterLink.js

```JavaScript
import { connect } from 'react-redux'
import { setVisibilityFilter } from '../actions'
import Link from '../components/Link'

const mapStateToProps = (state, ownProps) => {
  return {
    active: ownProps.filter === state.visibilityFilter
  }
}

const mapDispatchToProps = (dispatch, ownProps) => {
  return {
    onClick: () => {
      dispatch(setVisibilityFilter(ownProps.filter))
    }
  }
}

const FilterLink = connect(
  mapStateToProps,
  mapDispatchToProps
)(Link)

export default FilterLink
```

containers/VisibleTodoList.js

```JavaScript
import { connect } from 'react-redux'
import { toggleTodo } from '../actions'
import TodoList from '../components/TodoList'

const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case 'SHOW_ALL':
      return todos
    case 'SHOW_COMPLETED':
      return todos.filter(t => t.completed)
    case 'SHOW_ACTIVE':
      return todos.filter(t => !t.completed)
  }
}

const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}

const mapDispatchToProps = (dispatch) => {
  return {
    onTodoClick: (id) => {
      dispatch(toggleTodo(id))
    }
  }
}

const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList)

export default VisibleTodoList
```

## Other Components

containers/AddTodo.js

```JavaScript
import React from 'react'
import { connect } from 'react-redux'
import { addTodo } from '../actions'

let AddTodo = ({ dispatch }) => {
  let input

  return (
    <div>
      <input ref={node => {
        input = node
      }} />
      <button onClick={() => {
        dispatch(addTodo(input.value))
        input.value = ''
      }}>
        Add Todo
      </button>
    </div>
  )
}
AddTodo = connect()(AddTodo)

export default AddTodo
```

## Passing the Store

All container components need access to the Redux store so they can subscribe to it. One option would be to pass it as a prop to every container component. However it gets tedious, as you have to wire store even through presentational components just because they happen to render a container deep in the component tree.

æ‰€æœ‰å®¹å™¨ç±»componentéƒ½éœ€è¦è®¿é—®Redux storeï¼Œä»è€Œæ³¨å†Œç›‘å¬å™¨ç­‰ã€‚ä¸€ç§æ–¹æ³•æ˜¯ä»æœ€ä¸Šå±‚é€å±‚ä¼ å…¥storeã€‚ä½†æ˜¯ï¼Œè¿™ä¹Ÿå¤ªç‰¹ä¹ˆçƒ¦äº†å§ï¼Œæ¯•ç«Ÿä½ è¿˜è¦æŠŠstoreä¼ å…¥åˆ°å±•ç¤ºç±»componenté‡Œï¼Œå°±ä¸ºäº†åœ¨æ›´æ·±å±‚æ¬¡é‡Œçš„æŸä¸ªå®¹å™¨ç±»componentã€‚

The option we recommend is to use a special React Redux component called <Provider> to magically make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:

æˆ‘ä»¬æ¨èçš„æ–¹æ³•æ˜¯ä½¿ç”¨ä¸€ä¸ªç‰¹æ®Šçš„React Reduxçš„componentï¼Œå«åš&lt;Provider&gt;è¿™è´§å¯ä»¥ç¥å¥‡åœ°è®©æ‰€æœ‰å®¹å™¨éƒ½æ‹¥æœ‰storeå±æ€§ã€‚ä½ åªè¦åœ¨æ¸²æŸ“root componentçš„æ—¶å€™ä½¿ç”¨ä¸€æ¬¡å°±å¯ä»¥äº†ã€‚

index.js

```JavaScript
import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoApp from './reducers'
import App from './components/App'

let store = createStore(todoApp)

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)
```

## Next Steps

Read the complete source code for this tutorial to better internalize the knowledge you have gained. Then, head straight to the advanced tutorial to learn how to handle network requests and routing!
